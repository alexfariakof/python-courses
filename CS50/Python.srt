0
00:00:05,000 --> 00:00:05,024


1
00:00:05,024 --> 00:00:07,940
DOUG LLOYD: As we continue to put C in the rear view mirror behind us,

2
00:00:07,940 --> 00:00:10,481
I wanted to now introduce you to another programming language

3
00:00:10,481 --> 00:00:12,023
that we'll use a lot in CS50, Python.

4
00:00:12,023 --> 00:00:14,939
Now, of course we're not going to be able to cover Python in nearly as

5
00:00:14,939 --> 00:00:17,660
much depth as we spent in those 30 or so videos we spent

6
00:00:17,660 --> 00:00:19,850
talking about C in prior weeks, but the goal here

7
00:00:19,850 --> 00:00:22,160
is really to give you an introduction to the language

8
00:00:22,160 --> 00:00:24,993
so you can see some of the tools it has and figure out how you might

9
00:00:24,993 --> 00:00:26,750
want to use them best on your own.

10
00:00:26,750 --> 00:00:29,761
Now, Python is an example of a pretty commonly used modern programming

11
00:00:29,761 --> 00:00:30,260
language.

12
00:00:30,260 --> 00:00:33,740
It's probably in the top five or six at the time this video is being recorded.

13
00:00:33,740 --> 00:00:35,240
It's been around though for a while.

14
00:00:35,240 --> 00:00:37,520
It's been around for over 25 years, and it's really

15
00:00:37,520 --> 00:00:41,970
a great language choice for making some complex operations in C a lot easier.

16
00:00:41,970 --> 00:00:45,530
So you may recall working with C that string manipulation

17
00:00:45,530 --> 00:00:47,740
can be really challenging.

18
00:00:47,740 --> 00:00:50,180
And it also simplifies things like networking

19
00:00:50,180 --> 00:00:52,867
and really it's a general purpose utility language

20
00:00:52,867 --> 00:00:54,450
that you can use to do a lot of stuff.

21
00:00:54,450 --> 00:00:57,200
It's also very popular right now among data scientists

22
00:00:57,200 --> 00:01:00,690
for processing large sets of data and generating graphs, charts,

23
00:01:00,690 --> 00:01:02,510
and results from that.

24
00:01:02,510 --> 00:01:04,010
There is some good news too as well.

25
00:01:04,010 --> 00:01:08,060
So Python is pretty inspired by C as a lot of modern programming languages

26
00:01:08,060 --> 00:01:09,940
are honestly.

27
00:01:09,940 --> 00:01:12,620
And its syntax is going to look a little bit different,

28
00:01:12,620 --> 00:01:17,266
but it has some pretty consistent look and feel things to it.

29
00:01:17,266 --> 00:01:20,390
You're not going to see as many curly braces or anything like that that you

30
00:01:20,390 --> 00:01:22,850
didn't in C, but hopefully some of the style

31
00:01:22,850 --> 00:01:26,277
lessons that you learned along the way will come in handy for you here.

32
00:01:26,277 --> 00:01:28,735
To start writing a Python file it's pretty straightforward.

33
00:01:28,735 --> 00:01:31,310
All you've got to do is open up a file with the dot py

34
00:01:31,310 --> 00:01:33,296
file extension inside of CS50 IDE.

35
00:01:33,296 --> 00:01:35,420
That will automatically syntax highlight it for you

36
00:01:35,420 --> 00:01:40,490
and show you that what you're typing is proper valid Python or not.

37
00:01:40,490 --> 00:01:45,245
But unlike C, Python is not a compiled language.

38
00:01:45,245 --> 00:01:48,050
Or it is not necessarily a compiled language.

39
00:01:48,050 --> 00:01:51,320
Python programs can be run in a Python interpreter.

40
00:01:51,320 --> 00:01:53,906
This is similar to PHP if you're familiar with that language

41
00:01:53,906 --> 00:01:56,030
as well where you can just write your lines of code

42
00:01:56,030 --> 00:02:00,740
and have the computer just run through them one by one executing as you go.

43
00:02:00,740 --> 00:02:01,820


44
00:02:01,820 --> 00:02:04,640
Python programs can work in exactly the same way.

45
00:02:04,640 --> 00:02:07,320
One really important caveat before we dive into this.

46
00:02:07,320 --> 00:02:09,324
In CS50, we teach Python 3.

47
00:02:09,324 --> 00:02:11,240
There are actually two pretty popular versions

48
00:02:11,240 --> 00:02:14,840
of Python, Python 2 and Python 3.

49
00:02:14,840 --> 00:02:17,840
So all the syntax and everything we're going to talk about in this video

50
00:02:17,840 --> 00:02:21,380
is Python 3 specific, and in general, if you're

51
00:02:21,380 --> 00:02:23,720
looking up documentation on your own trying

52
00:02:23,720 --> 00:02:26,027
to figure out how to use a Python function

53
00:02:26,027 --> 00:02:28,610
or figure out if there's a Python function that does something

54
00:02:28,610 --> 00:02:33,616
you're looking to do, be sure to include Python 3 in your search

55
00:02:33,616 --> 00:02:36,740
instead of just saying Python, because you might get Python 2 results which

56
00:02:36,740 --> 00:02:39,174
would not necessarily work.

57
00:02:39,174 --> 00:02:41,840
So let's go through some of the basic things that we can do in C

58
00:02:41,840 --> 00:02:44,150
and show you how we can do them in Python.

59
00:02:44,150 --> 00:02:48,200
So variables have two big differences from C.

60
00:02:48,200 --> 00:02:50,990
We don't have to specify a type anymore so that's pretty cool.

61
00:02:50,990 --> 00:02:52,948
And we can declare them only by initialization.

62
00:02:52,948 --> 00:02:55,040
So you may recall in C that we could declare

63
00:02:55,040 --> 00:02:58,220
a variable by sayings for example int x semicolon,

64
00:02:58,220 --> 00:03:01,130
but not actually assign a value to it, not initialize it.

65
00:03:01,130 --> 00:03:04,100
In Python, we can only declare variables by initializing them.

66
00:03:04,100 --> 00:03:08,630
So where in C we might say something like this, int x equals 54 semicolon.

67
00:03:08,630 --> 00:03:12,980
In Python, we just say x equals 54 and that creates a new variable for us

68
00:03:12,980 --> 00:03:16,470
in Python called x and assigns it the value 54.

69
00:03:16,470 --> 00:03:20,690
And notice here, Python statements don't need to end with semicolons.

70
00:03:20,690 --> 00:03:23,360
So that might be a nice thing if you're the kind of person who

71
00:03:23,360 --> 00:03:26,480
like me oftentimes will forget to put a semicolon at the end of a line.

72
00:03:26,480 --> 00:03:28,280
In Python you don't need to include them.

73
00:03:28,280 --> 00:03:30,420
You can include them and it won't have a problem,

74
00:03:30,420 --> 00:03:34,730
but you can also omit them to make your code look a little bit cleaner.

75
00:03:34,730 --> 00:03:38,750
Similarly, can we declare the following, string phrase equals this is CS50,

76
00:03:38,750 --> 00:03:41,395
and to do this in C we would have to pound include

77
00:03:41,395 --> 00:03:45,667
the CS50 library because string is not a native data type in C.

78
00:03:45,667 --> 00:03:46,500
But it is in Python.

79
00:03:46,500 --> 00:03:49,502
We can just say, phrase equals this is CS50.

80
00:03:49,502 --> 00:03:51,710
And in fact, we don't even have to use double quotes.

81
00:03:51,710 --> 00:03:55,132
Python actually support strings with double quotes or single quotes.

82
00:03:55,132 --> 00:03:56,840
And this is actually really useful if you

83
00:03:56,840 --> 00:04:01,235
need to declare a string that has quotation marks in it,

84
00:04:01,235 --> 00:04:03,110
you can just kind of alternate back and forth

85
00:04:03,110 --> 00:04:06,500
between using single quotes on the outside, double quotes on the inside,

86
00:04:06,500 --> 00:04:10,969
single quotes inside of that, and so on, and that's actually kind of useful

87
00:04:10,969 --> 00:04:14,010
if you're the kind of person who's working with a lot of text for example

88
00:04:14,010 --> 00:04:16,260
in particular with databases.

89
00:04:16,260 --> 00:04:19,173
The conditional statements from C are all available for you to use,

90
00:04:19,173 --> 00:04:21,089
but they might look a teeny bit different now.

91
00:04:21,089 --> 00:04:24,600
So whereas in C we might say something like this, if y is less than 43,

92
00:04:24,600 --> 00:04:27,464
or z equals equals 15, and then we have some code.

93
00:04:27,464 --> 00:04:29,130
That's not what it looks like in Python.

94
00:04:29,130 --> 00:04:31,630
It looks a little something like this.

95
00:04:31,630 --> 00:04:36,610
If y is less than 43 or literally using the word or now,

96
00:04:36,610 --> 00:04:39,890
not using two vertical bars, because in Python we can do that.

97
00:04:39,890 --> 00:04:43,950
Or z equals 15 colon, instead of open curly brace

98
00:04:43,950 --> 00:04:49,670
and then whatever code we have close curly brace and then some code below.

99
00:04:49,670 --> 00:04:53,160
In Python, all comments are introduced with the pound sign or hash

100
00:04:53,160 --> 00:04:54,280
mark like this.

101
00:04:54,280 --> 00:04:58,480
So this basically just indicates that this is a comment.

102
00:04:58,480 --> 00:05:00,880
So here's an if else statement that might be familiar

103
00:05:00,880 --> 00:05:04,360
with from C. In Python, it's going to look pretty similar.

104
00:05:04,360 --> 00:05:07,790
Again, it looks just like this where we now--

105
00:05:07,790 --> 00:05:09,640
well actually, we have and here.

106
00:05:09,640 --> 00:05:14,319
So previously in C we have if y is less than 43 and z is equal to 15.

107
00:05:14,319 --> 00:05:17,110
In Python, just like where or was translated from two vertical bars

108
00:05:17,110 --> 00:05:23,020
to the word or, in Python we've translated two ampersands

109
00:05:23,020 --> 00:05:23,890
to the word and.

110
00:05:23,890 --> 00:05:25,848
So we don't have to use two ampersands anymore,

111
00:05:25,848 --> 00:05:27,700
we can just literally say the word and.

112
00:05:27,700 --> 00:05:29,020
Then we have the else there.

113
00:05:29,020 --> 00:05:30,970
The else is not that big of a difference.

114
00:05:30,970 --> 00:05:32,720
This one is a little bit different though.

115
00:05:32,720 --> 00:05:35,170
So if course number equals 50 we do one thing.

116
00:05:35,170 --> 00:05:40,090
Else if course number is not equal to 51 we do something else.

117
00:05:40,090 --> 00:05:47,004
In Python, we don't have else if, we have elif, not elseif.

118
00:05:47,004 --> 00:05:49,170
But otherwise it's going to behave exactly the same.

119
00:05:49,170 --> 00:05:53,430
So just again, trying to cut a couple of characters out of what we have to type.

120
00:05:53,430 --> 00:05:58,440
And again, instead of using course num not equal to 51, we can do elif

121
00:05:58,440 --> 00:06:00,780
not course num equals 51.

122
00:06:00,780 --> 00:06:04,860
Again, it's a little bit of a twist, but we can again use these English words.

123
00:06:04,860 --> 00:06:08,430
We're not having to use the exclamation point symbol, the vertical bar

124
00:06:08,430 --> 00:06:12,375
symbol, the ampersand, all that sort of taking away that junk

125
00:06:12,375 --> 00:06:15,512
and we can just start to speak English almost in Python.

126
00:06:15,512 --> 00:06:18,720
And that's actually one of the reasons that people find this language popular

127
00:06:18,720 --> 00:06:22,620
is because generally, if you think you want to write something in English,

128
00:06:22,620 --> 00:06:25,890
you're actually pretty much on the way to writing it the same thing in Python.

129
00:06:25,890 --> 00:06:30,870
As I pointed out, we don't have else if, it's just one word here, elif.

130
00:06:30,870 --> 00:06:34,140
Just like before though, we end our lines now with colons

131
00:06:34,140 --> 00:06:35,520
and we indent our code blocks.

132
00:06:35,520 --> 00:06:37,650
And as we'll see a bit later, indenting in Python

133
00:06:37,650 --> 00:06:41,450
is super, super, super important.

134
00:06:41,450 --> 00:06:44,200
We also have question mark colon, the ternary operator.

135
00:06:44,200 --> 00:06:45,560
It looks a little bit different.

136
00:06:45,560 --> 00:06:47,320
I'm going to show it here just you see it,

137
00:06:47,320 --> 00:06:50,200
but generally it's a little bit weird so you might not

138
00:06:50,200 --> 00:06:51,762
use it all that frequently.

139
00:06:51,762 --> 00:06:54,220
So here what we're doing is we're getting a character in C,

140
00:06:54,220 --> 00:06:58,360
and then if that character is a letter, alphabetic gets assigned to the value

141
00:06:58,360 --> 00:07:01,480
true, otherwise it gets assigned to the value false.

142
00:07:01,480 --> 00:07:04,010
Here, that line would look like this.

143
00:07:04,010 --> 00:07:08,290
It's a single line of code, and we have our true and false.

144
00:07:08,290 --> 00:07:10,582
Notice that they are now capitalized as opposed to in C

145
00:07:10,582 --> 00:07:11,623
where they're lower case.

146
00:07:11,623 --> 00:07:13,870
Again, these little syntax differences are the kinds

147
00:07:13,870 --> 00:07:15,470
of things that when you're learning a new language,

148
00:07:15,470 --> 00:07:18,390
these are the things that will vary a little bit from language to language.

149
00:07:18,390 --> 00:07:20,560
But it's the general concepts here that we're concerned with

150
00:07:20,560 --> 00:07:22,600
and these will become second nature to you

151
00:07:22,600 --> 00:07:26,290
pretty quickly if you use Python for more than a week or so.

152
00:07:26,290 --> 00:07:28,510
We have this function called input, which we can use.

153
00:07:28,510 --> 00:07:29,810
It's native to Python.

154
00:07:29,810 --> 00:07:32,710
And we can use that to collect user input at the command line,

155
00:07:32,710 --> 00:07:37,491
just like we did in CS50's library with get char, get float, get int,

156
00:07:37,491 --> 00:07:37,990
and so on.

157
00:07:37,990 --> 00:07:39,430
Although those functions, again, are also

158
00:07:39,430 --> 00:07:40,888
available for you to use in Python.

159
00:07:40,888 --> 00:07:45,490
We rewrote them in Python for you.

160
00:07:45,490 --> 00:07:47,720
We have two kinds of loops in Python.

161
00:07:47,720 --> 00:07:48,730
So in C we had three.

162
00:07:48,730 --> 00:07:51,472
We had while loops, do while loops, and for loops.

163
00:07:51,472 --> 00:07:53,680
Here in Python, we don't have do while loops anymore.

164
00:07:53,680 --> 00:07:56,470
We only have the two, while and for, although they're

165
00:07:56,470 --> 00:07:58,450
a bit more flexible here.

166
00:07:58,450 --> 00:08:01,580
So here's an example of some C code where we're using a while loop.

167
00:08:01,580 --> 00:08:03,910
We initialize a counter to 0, and then so long

168
00:08:03,910 --> 00:08:07,986
as that counter is less than 100, we print out the number

169
00:08:07,986 --> 00:08:09,610
and then we increment the counter by 1.

170
00:08:09,610 --> 00:08:13,563
So this loop will run 100 times, printing the numbers 0 1 dot, dot, dot,

171
00:08:13,563 --> 00:08:15,870
dot, dot all the way down to 99.

172
00:08:15,870 --> 00:08:19,060
Do this same thing in Python, it would look a little something like this.

173
00:08:19,060 --> 00:08:21,610
Counter equals zero-- again, we're leaving off the type specifier

174
00:08:21,610 --> 00:08:23,193
because it's Python, we don't need it.

175
00:08:23,193 --> 00:08:25,060
There's no semicolons at the end.

176
00:08:25,060 --> 00:08:27,310
And then while counter is less than 100-- again,

177
00:08:27,310 --> 00:08:29,140
no extraneous parentheses here either.

178
00:08:29,140 --> 00:08:32,020
We're really trying to streamline what we can.

179
00:08:32,020 --> 00:08:35,765
Then we just print out the counter and we say, counter plus equals 1.

180
00:08:35,765 --> 00:08:38,400
This is another catch here in Python.

181
00:08:38,400 --> 00:08:41,230
Plus plus is not the increment by one operator.

182
00:08:41,230 --> 00:08:44,500
We have to very explicitly call out counter plus equals 1.

183
00:08:44,500 --> 00:08:46,309
We can't say counter plus plus.

184
00:08:46,309 --> 00:08:48,475
But otherwise, this would do exactly the same thing.

185
00:08:48,475 --> 00:08:53,320
Print out one line at a time the numbers 0 to 99.

186
00:08:53,320 --> 00:08:56,560
And notice also that we don't have to include that backslash n that we

187
00:08:56,560 --> 00:08:58,390
did in C when we were using printf.

188
00:08:58,390 --> 00:09:01,410
In Python, by default it assumes that if you're printing something,

189
00:09:01,410 --> 00:09:04,820
it's just going to tack a new line on at the very end for you automatically.

190
00:09:04,820 --> 00:09:06,276
So that's kind of nice.

191
00:09:06,276 --> 00:09:08,650
Here's a for loop that would do again pretty much exactly

192
00:09:08,650 --> 00:09:09,983
the same thing that we just saw.

193
00:09:09,983 --> 00:09:14,319
It initializes the variable x to 0, and then so long as x is less than 100

194
00:09:14,319 --> 00:09:16,360
it will print out the number, and then at the end

195
00:09:16,360 --> 00:09:19,330
of every iteration of the loop it will execute the line x plus plus.

196
00:09:19,330 --> 00:09:24,010
So we'll again have 0 1 dot, dot, dot, dot, dot all the way down to 99.

197
00:09:24,010 --> 00:09:26,470
In Python it looks a little something like this.

198
00:09:26,470 --> 00:09:30,580
For x in range 1000 print x.

199
00:09:30,580 --> 00:09:33,394
So range is a function that will give us basically a list,

200
00:09:33,394 --> 00:09:36,310
and we'll talk about what that is in just a moment, of all the numbers

201
00:09:36,310 --> 00:09:38,740
from 0 to 100 but not including 100.

202
00:09:38,740 --> 00:09:40,724
So this would give us a list of 0 to 99.

203
00:09:40,724 --> 00:09:43,390
And then we're just going to print out every number in that list

204
00:09:43,390 --> 00:09:45,820
starting at the beginning, going all the way to the end.

205
00:09:45,820 --> 00:09:48,370
In a for loop where we wanted to count by twos

206
00:09:48,370 --> 00:09:50,219
we might do something like this.

207
00:09:50,219 --> 00:09:52,010
In Python we can also do that, we just have

208
00:09:52,010 --> 00:09:55,870
to add one extra parameter to our range function.

209
00:09:55,870 --> 00:09:59,290
We set a start point, we set with the endpoint,

210
00:09:59,290 --> 00:10:02,020
and we set how much we want to skip by.

211
00:10:02,020 --> 00:10:05,410
So this is a list of all of the integers from up to 100

212
00:10:05,410 --> 00:10:08,570
but not counting 100, counting by twos.

213
00:10:08,570 --> 00:10:13,350
So this would generate a list for us of 0, 2, 4, 6, 8 and so on all the way

214
00:10:13,350 --> 00:10:16,080
up to 98.

215
00:10:16,080 --> 00:10:17,400
So arrays.

216
00:10:17,400 --> 00:10:19,380
So arrays are really where Python is going

217
00:10:19,380 --> 00:10:21,810
to start to shine and show us some of the real advantages

218
00:10:21,810 --> 00:10:25,407
it has over a language like C, which is a little more constricted in what

219
00:10:25,407 --> 00:10:27,240
it can do with arrays because of two things.

220
00:10:27,240 --> 00:10:31,650
One, they're fixed size, and two, we can only store one type of variable

221
00:10:31,650 --> 00:10:32,370
in them.

222
00:10:32,370 --> 00:10:35,610
We can only store an array of all integers, all characters, all

223
00:10:35,610 --> 00:10:38,310
some structure that we created, and so on.

224
00:10:38,310 --> 00:10:40,410
In Python, we don't actually call them arrays.

225
00:10:40,410 --> 00:10:44,010
We call them lists, but they're effectively the same general idea,

226
00:10:44,010 --> 00:10:46,200
the same concept we're familiar with.

227
00:10:46,200 --> 00:10:47,550
They're not fixed in size.

228
00:10:47,550 --> 00:10:51,570
So similar to a linked list really we can grow and shrink them as we need,

229
00:10:51,570 --> 00:10:53,970
as our program demands more memory or less memory

230
00:10:53,970 --> 00:10:57,060
to be consumed by the list the language is flexible enough

231
00:10:57,060 --> 00:10:58,890
to allow us to do that.

232
00:10:58,890 --> 00:11:03,180
And we can always add more things on, splice or remove things from the middle

233
00:11:03,180 --> 00:11:04,540
pretty easily.

234
00:11:04,540 --> 00:11:07,530
So let's get in the habit of calling these things lists now instead

235
00:11:07,530 --> 00:11:08,726
of arrays.

236
00:11:08,726 --> 00:11:11,100
But to declare a list it's really pretty straightforward.

237
00:11:11,100 --> 00:11:13,811
Nums equals square brackets.

238
00:11:13,811 --> 00:11:14,310
There we go.

239
00:11:14,310 --> 00:11:14,809
We have it.

240
00:11:14,809 --> 00:11:18,050
That's an empty list or an empty array.

241
00:11:18,050 --> 00:11:20,970
But that's all we really need to do to do it.

242
00:11:20,970 --> 00:11:24,660
We could create a list that has a couple of elements pre-populated into it.

243
00:11:24,660 --> 00:11:27,420
Nums equals 1, 2, 3, 4.

244
00:11:27,420 --> 00:11:32,160
That is an explicitly created list.

245
00:11:32,160 --> 00:11:35,160
Python also has support for something called a list comprehension, which

246
00:11:35,160 --> 00:11:36,970
we're not going to get into in a lot of detail here,

247
00:11:36,970 --> 00:11:38,720
but I want to show you what it looks like.

248
00:11:38,720 --> 00:11:42,720
Nums equals x, and then I have a for loop inside

249
00:11:42,720 --> 00:11:45,102
of my declaration of my list.

250
00:11:45,102 --> 00:11:48,060
This is called the list comprehension, and basically what this is doing

251
00:11:48,060 --> 00:11:52,520
is I'm using the for loop to generate a list of numbers for me.

252
00:11:52,520 --> 00:11:55,770
And instead of doing anything with that list like where I as printing them out

253
00:11:55,770 --> 00:11:59,010
before, I'm using that list that the for loop

254
00:11:59,010 --> 00:12:02,620
generates to assign it to nums instead.

255
00:12:02,620 --> 00:12:06,840
So what this would do is create a list of 500 elements, all

256
00:12:06,840 --> 00:12:10,470
of the numbers up from 0 all the way up to 499,

257
00:12:10,470 --> 00:12:13,530
because again range excludes that final parameter.

258
00:12:13,530 --> 00:12:15,600
So we're not including 500.

259
00:12:15,600 --> 00:12:20,980
Our range has 500 things in it, but it's going from 0 to 499, not 0 to 500

260
00:12:20,980 --> 00:12:24,190
which would be 501 things in the list.

261
00:12:24,190 --> 00:12:26,100
Now, instead of the square bracket syntax,

262
00:12:26,100 --> 00:12:28,882
there's also just saying nums equals list parentheses, which

263
00:12:28,882 --> 00:12:31,590
is a function that creates a list, and if you don't pass anything

264
00:12:31,590 --> 00:12:34,990
in it returns an empty list or an empty set of square brackets.

265
00:12:34,990 --> 00:12:37,980
So that's exactly the same as what we saw just a moment ago

266
00:12:37,980 --> 00:12:39,957
with the blank empty list.

267
00:12:39,957 --> 00:12:41,040
Now we have the following.

268
00:12:41,040 --> 00:12:43,190
We could say nums equals 1, 2, 3, 4.

269
00:12:43,190 --> 00:12:45,930
So that's explicitly creating a list of four elements.

270
00:12:45,930 --> 00:12:48,330
We can attach an element to the end of the list.

271
00:12:48,330 --> 00:12:51,070
We can say, nums dot append 5.

272
00:12:51,070 --> 00:12:54,990
And what that's going to do is that's going to add 5 to the end of the list.

273
00:12:54,990 --> 00:12:57,570
It's going to tack it on at the very end.

274
00:12:57,570 --> 00:13:00,120
This line of code would do exactly the same thing.

275
00:13:00,120 --> 00:13:02,577
Nums dot insert parentheses 4 comma 5.

276
00:13:02,577 --> 00:13:03,660
Well, what does this mean?

277
00:13:03,660 --> 00:13:07,620
Well, what's happening here is we're inserting in the fourth position,

278
00:13:07,620 --> 00:13:10,200
again counting from 0, and if you remember

279
00:13:10,200 --> 00:13:14,910
how we count in C we know that 1 here is in the zeroth position,

280
00:13:14,910 --> 00:13:18,450
2 is in the first position, 3 is in the second position,

281
00:13:18,450 --> 00:13:19,829
4 is in the third position.

282
00:13:19,829 --> 00:13:21,870
So what we're doing here is really just inserting

283
00:13:21,870 --> 00:13:25,240
into the fourth position the value 5.

284
00:13:25,240 --> 00:13:28,570
So this line, and this one that we just saw do exactly the same thing.

285
00:13:28,570 --> 00:13:32,430
They put a 5 at the end of that array.

286
00:13:32,430 --> 00:13:34,770
This also does the same thing.

287
00:13:34,770 --> 00:13:39,994
Nums square bracket len nums colon 5 equals 5.

288
00:13:39,994 --> 00:13:42,660
Little bit weirder, but basically what we're doing here is we're

289
00:13:42,660 --> 00:13:47,790
creating another list effectively, and we're splicing it

290
00:13:47,790 --> 00:13:50,190
on to the one that exists before.

291
00:13:50,190 --> 00:13:52,270
So what I'm saying is, I'm creating a new list.

292
00:13:52,270 --> 00:13:55,590
There's a list there with a single element, 5.

293
00:13:55,590 --> 00:14:01,320
And I'm saying, the nums list from position 4, which is the length of nums

294
00:14:01,320 --> 00:14:04,130
forward, gets this list assigned to it.

295
00:14:04,130 --> 00:14:07,890
So if i had put 5 comma 6 there, after this would execute

296
00:14:07,890 --> 00:14:11,550
I would end up with nums equals 1, 2, 3, 4, 5, 6.

297
00:14:11,550 --> 00:14:15,456
So this is how I can perhaps attach one list

298
00:14:15,456 --> 00:14:17,580
to the end of another list, as opposed to attaching

299
00:14:17,580 --> 00:14:22,480
one element to the end of a list.

300
00:14:22,480 --> 00:14:26,542
So len nums works just like strlen might if you're familiar with that from C.

301
00:14:26,542 --> 00:14:28,000
It calculates the length of a list.

302
00:14:28,000 --> 00:14:30,960
So len now becomes a function in Python that

303
00:14:30,960 --> 00:14:34,630
is usable to calculate not just the length of a string,

304
00:14:34,630 --> 00:14:37,570
but the length of any arbitrary list.

305
00:14:37,570 --> 00:14:39,910
Kind of useful.

306
00:14:39,910 --> 00:14:42,180
All right, here's a new data type that we've never--

307
00:14:42,180 --> 00:14:44,200
or a new kind of way of storing data in Python

308
00:14:44,200 --> 00:14:47,440
that we're not familiar with from C and that's called a tuple.

309
00:14:47,440 --> 00:14:52,870
So what a tuple is, it is an ordered, immutable set of data,

310
00:14:52,870 --> 00:14:57,310
basically what we're saying here is we have a collection of a couple of things

311
00:14:57,310 --> 00:15:01,730
that we will never change, but the order matters.

312
00:15:01,730 --> 00:15:05,137
And we'll take a look at an example in just a moment of what a tuple might

313
00:15:05,137 --> 00:15:07,220
look like or what a list of tuples might look like

314
00:15:07,220 --> 00:15:09,230
and why we might want to work them.

315
00:15:09,230 --> 00:15:11,930
But they're really good for associating collections of data.

316
00:15:11,930 --> 00:15:15,070
They're really fast to navigate in Python.

317
00:15:15,070 --> 00:15:18,320
And they're really kind of analogous to a structure in C where the values will

318
00:15:18,320 --> 00:15:20,930
never change, but you've arranged them because of the way

319
00:15:20,930 --> 00:15:24,930
you arranged your fields in C in a particular order.

320
00:15:24,930 --> 00:15:27,500
So here, for example is a list--

321
00:15:27,500 --> 00:15:29,330
so a list which we just talked about--

322
00:15:29,330 --> 00:15:30,870
of tuples.

323
00:15:30,870 --> 00:15:33,200
So we're mixing these two concepts together here.

324
00:15:33,200 --> 00:15:34,910
Here is a list of tuples.

325
00:15:34,910 --> 00:15:39,920
This is a list called presidents that contains four tuples,

326
00:15:39,920 --> 00:15:42,720
George Washington comma 1789 in parentheses--

327
00:15:42,720 --> 00:15:44,780
that's how we indicate a tuple--

328
00:15:44,780 --> 00:15:48,120
John Adams comma 1797, and so on and so on.

329
00:15:48,120 --> 00:15:53,390
Each of these, each of George Washington 1789 and John Adams 1797 and so on,

330
00:15:53,390 --> 00:15:54,980
that is a single tuple.

331
00:15:54,980 --> 00:15:57,980
And then you see here that we have the commas at the end of those tuples

332
00:15:57,980 --> 00:16:03,320
to indicate that all of those are items in the larger list called presidents.

333
00:16:03,320 --> 00:16:07,252
Now, we can iterate over this list and do things with it.

334
00:16:07,252 --> 00:16:09,710
So let's take a look at an example of how we might do that.

335
00:16:09,710 --> 00:16:15,450
So up at the top right is our presidents list from just the previous slide.

336
00:16:15,450 --> 00:16:17,420
And I can do the following.

337
00:16:17,420 --> 00:16:20,660
For prez comma year in presidents.

338
00:16:20,660 --> 00:16:23,510
So now, notice, I'm not just saying for x in range

339
00:16:23,510 --> 00:16:31,309
where I'm using one iterator, I have two, prez comma year.

340
00:16:31,309 --> 00:16:33,350
And if you look, you'll notice that that actually

341
00:16:33,350 --> 00:16:36,630
matches what I have there in the presidents list.

342
00:16:36,630 --> 00:16:44,270
I have a set of four tuples where each is arranged prez comma year.

343
00:16:44,270 --> 00:16:45,680
Then I'm doing something weird.

344
00:16:45,680 --> 00:16:47,850
Print in square bracket--

345
00:16:47,850 --> 00:16:52,970
in curly brackets 1 curly bracket 0 took office dot format prez year.

346
00:16:52,970 --> 00:16:54,440
What is happening?

347
00:16:54,440 --> 00:16:57,020
This is actually just how the print function in Python

348
00:16:57,020 --> 00:17:02,360
does what printf does in C. Instead of using percent s or percent c or percent

349
00:17:02,360 --> 00:17:05,570
d, those format specifiers that we're used to from C,

350
00:17:05,570 --> 00:17:10,240
here we use the dot format method, which we'll

351
00:17:10,240 --> 00:17:14,896
talk about again in just a moment, at the end of the print function.

352
00:17:14,896 --> 00:17:18,020
And we can specify the order in which we want those parameters to come out.

353
00:17:18,020 --> 00:17:21,660
So the 1 and 0 there match like this.

354
00:17:21,660 --> 00:17:24,116
Now granted, I wrote this deliberately to show you

355
00:17:24,116 --> 00:17:25,490
that I could rearrange this list.

356
00:17:25,490 --> 00:17:28,339
I also could have just swapped prez and year

357
00:17:28,339 --> 00:17:30,819
and I wouldn't need the numbers at all.

358
00:17:30,819 --> 00:17:32,569
If you leave them out it will just go left

359
00:17:32,569 --> 00:17:37,280
to right through whatever the arguments are to format and plug those in left

360
00:17:37,280 --> 00:17:40,850
to right just to fill in all of the curly brace emptiness's

361
00:17:40,850 --> 00:17:42,350
that you have in the print function.

362
00:17:42,350 --> 00:17:45,360
But here, I can also explicitly take them out of order if I want it.

363
00:17:45,360 --> 00:17:47,100
So that's all I'm doing here.

364
00:17:47,100 --> 00:17:49,220
I'm getting a list.

365
00:17:49,220 --> 00:17:51,880
I'm getting a single tuple from this list

366
00:17:51,880 --> 00:17:57,950
and I'm basically printing its elements in reverse order plugging them in.

367
00:17:57,950 --> 00:18:00,860
So again, a contrived example, but I deliberately put

368
00:18:00,860 --> 00:18:03,900
it here to show you the flexibility of the print function

369
00:18:03,900 --> 00:18:06,140
and to introduced several concepts to you at once

370
00:18:06,140 --> 00:18:08,840
because you also are probably going to see a lot of things

371
00:18:08,840 --> 00:18:11,381
like this when you're doing research and trying to figure out

372
00:18:11,381 --> 00:18:12,680
what Python functions to use.

373
00:18:12,680 --> 00:18:15,679
You'll see a lot of unfamiliar things sort of blending together at once.

374
00:18:15,679 --> 00:18:19,130
So I wanted to just kind of introduce it to you here as well.

375
00:18:19,130 --> 00:18:22,620
But you can probably guess what this is going to do.

376
00:18:22,620 --> 00:18:24,380
It'll print out the following.

377
00:18:24,380 --> 00:18:28,692
In 1789 George Washington took office, In 1797 John Adams

378
00:18:28,692 --> 00:18:29,650
took office, and so on.

379
00:18:29,650 --> 00:18:31,880
It's going to iterate through the list and print out

380
00:18:31,880 --> 00:18:33,890
each tuple plugging in its values.

381
00:18:33,890 --> 00:18:37,340
And because I have the 1 and 0 there as opposed to just leaving them blank,

382
00:18:37,340 --> 00:18:39,700
it swaps the order of them.

383
00:18:39,700 --> 00:18:41,880
OK?

384
00:18:41,880 --> 00:18:44,599
Another thing that we're sort of familiar with in C,

385
00:18:44,599 --> 00:18:46,890
although it's not native, we had to build it ourselves,

386
00:18:46,890 --> 00:18:48,435
is the concept of a dictionary.

387
00:18:48,435 --> 00:18:53,707
Now dictionary is generally close in spirit to the concept of a hash table.

388
00:18:53,707 --> 00:18:55,790
And remember that hash tables were not native to C

389
00:18:55,790 --> 00:18:58,350
although they are native to a lot of programming languages.

390
00:18:58,350 --> 00:19:00,750
We had to build it ourselves.

391
00:19:00,750 --> 00:19:04,650
So it allows us to associate indexes with keys as opposed

392
00:19:04,650 --> 00:19:06,930
to integers, which we had to do in C. So if we

393
00:19:06,930 --> 00:19:09,150
wanted to have, for example, an array of something,

394
00:19:09,150 --> 00:19:11,970
we could only refer to the elements of the array

395
00:19:11,970 --> 00:19:16,650
by an index number, array square bracket 0, array square bracket 1, and so on.

396
00:19:16,650 --> 00:19:20,700
In Python, we can now associate elements of a list

397
00:19:20,700 --> 00:19:26,550
or elements in this case of a dictionary with keywords as opposed to integers.

398
00:19:26,550 --> 00:19:31,390
So for example, here is a dictionary of pizzas.

399
00:19:31,390 --> 00:19:34,010
So again, familiarize yourself with the different types

400
00:19:34,010 --> 00:19:35,010
of brackets we're using.

401
00:19:35,010 --> 00:19:37,110
So remember, in lists we have square brackets

402
00:19:37,110 --> 00:19:40,020
to indicate the beginning and end of a list.

403
00:19:40,020 --> 00:19:44,550
In tuples we use parentheses to indicate the beginning and end of a tuple.

404
00:19:44,550 --> 00:19:46,590
In dictionaries we use curly braces to indicate

405
00:19:46,590 --> 00:19:49,200
the beginning and end of a dictionary.

406
00:19:49,200 --> 00:19:53,070
Inside of this pizza dictionary I have four key value pairs.

407
00:19:53,070 --> 00:19:56,940
I associate the key cheese with the value 9,

408
00:19:56,940 --> 00:20:01,592
I associate the key peperoni with the value 10, and so on.

409
00:20:01,592 --> 00:20:03,300
Now, how might we want to work with this?

410
00:20:03,300 --> 00:20:05,220
These again are out keys.

411
00:20:05,220 --> 00:20:08,250
We use a colon to separate the key value pair.

412
00:20:08,250 --> 00:20:12,600
And we specify-- and those are our values here in green.

413
00:20:12,600 --> 00:20:18,240
I can change the value of different key value pairs in the dictionary as well.

414
00:20:18,240 --> 00:20:21,690
So I could say pizzas square bracket cheese equals 8,

415
00:20:21,690 --> 00:20:27,030
and now the key cheese is not associated with 9, it's associated with 8.

416
00:20:27,030 --> 00:20:31,230
I could use the different keys in my dictionary

417
00:20:31,230 --> 00:20:32,880
in Boolean expressions like this.

418
00:20:32,880 --> 00:20:36,420
If pizza square bracket vegetables is less than 12 I could do something.

419
00:20:36,420 --> 00:20:38,460
I can also add new keys to the dictionary,

420
00:20:38,460 --> 00:20:42,670
key value pairs the dictionary, without having to do anything crazy.

421
00:20:42,670 --> 00:20:46,690
Pizzas bacon, that key didn't exist before, equals 14.

422
00:20:46,690 --> 00:20:49,770
Now we have a dictionary that has five different key value pairs in it.

423
00:20:49,770 --> 00:20:52,820
Again, pretty straightforward to do.

424
00:20:52,820 --> 00:20:55,080
But we've introduced a new problem.

425
00:20:55,080 --> 00:20:59,902
If we don't have integer based indexes like we did in C,

426
00:20:59,902 --> 00:21:01,610
how do we iterate through the dictionary?

427
00:21:01,610 --> 00:21:03,670
We can't just iterate over the--

428
00:21:03,670 --> 00:21:06,170
I guess we could maybe iterate over the keys alphabetically,

429
00:21:06,170 --> 00:21:08,295
but then we would have to sort them alphabetically.

430
00:21:08,295 --> 00:21:10,820
That feels kind of messy.

431
00:21:10,820 --> 00:21:13,280
Fortunately, we can do this, and it's because

432
00:21:13,280 --> 00:21:14,750
of the flexibility of the for loop.

433
00:21:14,750 --> 00:21:16,100
And I pointed that out to you a little bit earlier

434
00:21:16,100 --> 00:21:19,224
and I said we'd come back to talk about how the for loop was more flexible.

435
00:21:19,224 --> 00:21:21,210
Let's see an example of this.

436
00:21:21,210 --> 00:21:26,300
So the for loop is not just used to count from one number up to another.

437
00:21:26,300 --> 00:21:31,890
We can also use it to iterate over the elements of a dictionary.

438
00:21:31,890 --> 00:21:35,840
So instead of saying for x in range 500, which is going to do something

439
00:21:35,840 --> 00:21:41,237
500 times, I can say for pie in pizzas.

440
00:21:41,237 --> 00:21:42,320
That's pretty cool, right?

441
00:21:42,320 --> 00:21:44,528
So what it's going to do there is it's going to use--

442
00:21:44,528 --> 00:21:46,250
pie basically becomes every single key.

443
00:21:46,250 --> 00:21:51,110
So cheese, bacon, vegetable, pepperoni, whatever else I had in there, that's

444
00:21:51,110 --> 00:21:54,110
how we iterate over all of those keys in Python

445
00:21:54,110 --> 00:21:59,850
without having the value of integers that we did previously.

446
00:21:59,850 --> 00:22:03,080
So for example, here's the original pizzas dictionary

447
00:22:03,080 --> 00:22:04,730
that we had just a moment ago.

448
00:22:04,730 --> 00:22:09,530
If I say for pie in pizzas print pie, because again pie is substituting

449
00:22:09,530 --> 00:22:12,410
for the keys, this is going to print out for me a list

450
00:22:12,410 --> 00:22:14,660
of all of the keys in my dictionary.

451
00:22:14,660 --> 00:22:18,770
So these are maybe the kinds of pizzas that I have available.

452
00:22:18,770 --> 00:22:23,630
Or for pie comma price in pizzas dot items-- now

453
00:22:23,630 --> 00:22:26,930
I have to specify pizzas items here to make it

454
00:22:26,930 --> 00:22:29,330
so that it can iterate over all of the keys.

455
00:22:29,330 --> 00:22:31,040
Excuse me, over all of the values.

456
00:22:31,040 --> 00:22:34,070
I can iterate over all of the keys automatically in a dictionary.

457
00:22:34,070 --> 00:22:35,810
But if I want to iterate over the values,

458
00:22:35,810 --> 00:22:40,400
I have to transform the dictionary into a list.

459
00:22:40,400 --> 00:22:44,180
In order to do that, I need to use the dot items

460
00:22:44,180 --> 00:22:46,970
method to transform my dictionary into a list for purposes

461
00:22:46,970 --> 00:22:48,450
of just iterating over this.

462
00:22:48,450 --> 00:22:49,770
Then I can print out the price.

463
00:22:49,770 --> 00:22:55,519
So in this case, I would print out 12, 10, 9, 11.

464
00:22:55,519 --> 00:22:56,060
That's weird.

465
00:22:56,060 --> 00:22:57,690
It didn't print them out in the order I specified

466
00:22:57,690 --> 00:23:00,106
and that's kind of a side effect here with the dictionary.

467
00:23:00,106 --> 00:23:02,180
You're not necessarily going to get your--

468
00:23:02,180 --> 00:23:05,587
when you transform the dictionary into a list to iterate over it as we do here,

469
00:23:05,587 --> 00:23:08,420
you're not guaranteed that that list is going to maintain its order.

470
00:23:08,420 --> 00:23:11,810
Now, the keys and values will still be associated correctly,

471
00:23:11,810 --> 00:23:15,350
if I wanted to print out both as we'll see in just a second.

472
00:23:15,350 --> 00:23:17,280
But the order is not guaranteed anymore.

473
00:23:17,280 --> 00:23:19,290
Now usually that's not going to be a problem.

474
00:23:19,290 --> 00:23:20,405
Sometimes it might be, in which case you're just going

475
00:23:20,405 --> 00:23:22,840
to have to use a list at the outset.

476
00:23:22,840 --> 00:23:25,320
And there are, of course, ways around it.

477
00:23:25,320 --> 00:23:28,280
Let's say I wanted to print both the key and the value.

478
00:23:28,280 --> 00:23:30,680
It's very similar to what I just had before.

479
00:23:30,680 --> 00:23:34,130
I'm still iterating over pie and price, and I'm still

480
00:23:34,130 --> 00:23:36,710
transforming the pizzas dictionary into a list

481
00:23:36,710 --> 00:23:39,340
temporarily so I can iterate over it.

482
00:23:39,340 --> 00:23:41,090
And I'm using my print function again here

483
00:23:41,090 --> 00:23:43,880
with now I'm not specifying 0 and 1.

484
00:23:43,880 --> 00:23:47,880
I could, and specify 0 in the first one, 1 in the second one.

485
00:23:47,880 --> 00:23:50,930
But I want to actually print the key first then the value.

486
00:23:50,930 --> 00:23:54,634
I don't want to have to invert them so I don't have to plug in the ordering

487
00:23:54,634 --> 00:23:57,050
that I did before when I was doing the presidents example,

488
00:23:57,050 --> 00:23:58,383
iterating over all those tuples.

489
00:23:58,383 --> 00:23:59,360


490
00:23:59,360 --> 00:24:02,480
And this would print out, a whole Buffalo chicken pizza

491
00:24:02,480 --> 00:24:05,570
costs $12, a whole cheese pizza costs $9.

492
00:24:05,570 --> 00:24:10,040
Again, going through each element and getting the key value pair

493
00:24:10,040 --> 00:24:12,260
and printing it out as I indicated.

494
00:24:12,260 --> 00:24:14,966
So that's how I can iterate over an entire dictionary,

495
00:24:14,966 --> 00:24:16,340
printing out all of its elements.

496
00:24:16,340 --> 00:24:18,980
Again, with the caveat that it's not ordered,

497
00:24:18,980 --> 00:24:22,220
so I'm not guaranteed to get them in exactly the same order I put them in.

498
00:24:22,220 --> 00:24:27,490
But again, that trade off is probably going to be worth it most of the time.

499
00:24:27,490 --> 00:24:30,244
So now we've seen a lot of examples of this.

500
00:24:30,244 --> 00:24:32,410
How to interpolate variables similar to printf where

501
00:24:32,410 --> 00:24:34,540
we would use percent substitution.

502
00:24:34,540 --> 00:24:36,910
In Python, we've seen this one quite a few times.

503
00:24:36,910 --> 00:24:40,890
There's also this one which would allow us to concatenate strings together.

504
00:24:40,890 --> 00:24:42,640
So here, I'm not doing any interprolation,

505
00:24:42,640 --> 00:24:48,160
but I'm plugging in the variable pie and the variable price,

506
00:24:48,160 --> 00:24:51,100
transforming it into a string, because everything else here

507
00:24:51,100 --> 00:24:53,683
is the string so I need to transform that number into a string

508
00:24:53,683 --> 00:24:55,450
to make this work correctly.

509
00:24:55,450 --> 00:24:57,430
So that's what the str function there does.

510
00:24:57,430 --> 00:24:59,140
But this again would work.

511
00:24:59,140 --> 00:25:05,240
So a whole cheese pizza costs dollars 9 turned into a string.

512
00:25:05,240 --> 00:25:08,320
You might see this, which is actually really similar to you from printf

513
00:25:08,320 --> 00:25:10,490
but it's deprecated in Python 3.

514
00:25:10,490 --> 00:25:14,020
So you don't really want to use it even though it might be more familiar to you

515
00:25:14,020 --> 00:25:16,180
because it's similar to printf.

516
00:25:16,180 --> 00:25:20,000
So you might see it, but try and avoid using it because it is deprecated.

517
00:25:20,000 --> 00:25:23,500
So again, Python is not just a main function

518
00:25:23,500 --> 00:25:25,297
that we just run down the lines.

519
00:25:25,297 --> 00:25:27,130
In fact, Python doesn't have a main function

520
00:25:27,130 --> 00:25:29,500
by default. We have to explicitly force it

521
00:25:29,500 --> 00:25:31,380
to have a main function if we want to.

522
00:25:31,380 --> 00:25:33,294
But it does support functions more generally.

523
00:25:33,294 --> 00:25:35,710
And we don't need to specify the return type of functions.

524
00:25:35,710 --> 00:25:38,400
And we don't need to specify the data types of any parameters.

525
00:25:38,400 --> 00:25:43,120
So you might recall from C that we had to specify like int square maybe

526
00:25:43,120 --> 00:25:47,060
it took an integer as its input, so int square parentheses int x semicolon

527
00:25:47,060 --> 00:25:48,822
or all this stuff we have going on.

528
00:25:48,822 --> 00:25:50,530
We don't have to any of those data types.

529
00:25:50,530 --> 00:25:53,590
We just have to specify the name of the function and any parameters

530
00:25:53,590 --> 00:25:54,850
that it takes.

531
00:25:54,850 --> 00:25:57,910
We introduce a function using the keyword def.

532
00:25:57,910 --> 00:26:01,162
So basically, think about it as like defining the following function.

533
00:26:01,162 --> 00:26:03,370
And because the interpreter reads from top to bottom,

534
00:26:03,370 --> 00:26:05,470
we don't have to include our main function.

535
00:26:05,470 --> 00:26:09,580
But if we want to include main because maybe we wrote our code such that

536
00:26:09,580 --> 00:26:12,964
the stuff we want to execute first actually is maybe 200 lines

537
00:26:12,964 --> 00:26:14,880
into our file-- we wrote other stuff up above,

538
00:26:14,880 --> 00:26:18,070
maybe we're keeping our functions in alphabetical order or whatever else--

539
00:26:18,070 --> 00:26:23,140
we can explicitly direct our program to start at the main function

540
00:26:23,140 --> 00:26:27,506
by including this line at the very, very end of our Python file.

541
00:26:27,506 --> 00:26:29,130
And this is just something to memorize.

542
00:26:29,130 --> 00:26:33,640
If underscore underscore name underscore underscore equals equals

543
00:26:33,640 --> 00:26:39,280
quote underscore underscore main underscore underscore quote colon

544
00:26:39,280 --> 00:26:41,351
and then tab in main parentheses.

545
00:26:41,351 --> 00:26:43,600
This is one of those things that you don't necessarily

546
00:26:43,600 --> 00:26:45,130
have to use because you write your code such

547
00:26:45,130 --> 00:26:47,088
that the first line is the first thing you want

548
00:26:47,088 --> 00:26:49,030
to happen it's going to be fine anyway.

549
00:26:49,030 --> 00:26:50,770
But if you write it out of order, this is

550
00:26:50,770 --> 00:26:52,894
just one of those things you just have to memorize.

551
00:26:52,894 --> 00:26:54,100
Sorry.

552
00:26:54,100 --> 00:26:56,060
So defining a function, pretty straightforward.

553
00:26:56,060 --> 00:26:58,390
Let's define the square of x like we just

554
00:26:58,390 --> 00:27:04,210
did a second ago in C. Def square parentheses x colon return x times x.

555
00:27:04,210 --> 00:27:05,300
Pretty straightforward.

556
00:27:05,300 --> 00:27:06,230
I could also do this.

557
00:27:06,230 --> 00:27:09,550
I could return x times times 2.

558
00:27:09,550 --> 00:27:13,210
Well, actually this operator here is a built in, which did not have,

559
00:27:13,210 --> 00:27:14,290
exponentiation operator.

560
00:27:14,290 --> 00:27:16,357
So this is return x squared.

561
00:27:16,357 --> 00:27:18,940
I could also be really convoluted and write my square function

562
00:27:18,940 --> 00:27:21,174
by adding x to itself x times.

563
00:27:21,174 --> 00:27:22,090
Doesn't really matter.

564
00:27:22,090 --> 00:27:24,805
As long as the result is the same, it can be a black box

565
00:27:24,805 --> 00:27:26,805
just like we talked about an out function video.

566
00:27:26,805 --> 00:27:29,809
We don't necessarily care how the square function is defined,

567
00:27:29,809 --> 00:27:31,600
as long as it does what we expect it to do.

568
00:27:31,600 --> 00:27:36,456
As long as printing the square of 5 prints out 25.

569
00:27:36,456 --> 00:27:39,260
All right, now here's something entirely different.

570
00:27:39,260 --> 00:27:40,970
Let's talk about objects.

571
00:27:40,970 --> 00:27:44,630
So objects we have not covered yet in CS50.

572
00:27:44,630 --> 00:27:47,300
And Python is an object oriented programming language.

573
00:27:47,300 --> 00:27:52,130
The closest thing we have to an object is a C structure.

574
00:27:52,130 --> 00:27:55,820
So C structures, you may recall, have a number of fields in them.

575
00:27:55,820 --> 00:27:59,330
We might call those fields, particularly in an object oriented context,

576
00:27:59,330 --> 00:28:00,296
properties.

577
00:28:00,296 --> 00:28:03,420
But those properties are never kind of able to just be on their own, right?

578
00:28:03,420 --> 00:28:08,220
They're always bound up and tied into some definition of some C structure.

579
00:28:08,220 --> 00:28:12,200
So if I define in C here, as I do at the top right, a car structure that

580
00:28:12,200 --> 00:28:17,180
has two fields or two properties in it, year and model,

581
00:28:17,180 --> 00:28:18,800
I might be able to say the following.

582
00:28:18,800 --> 00:28:22,850
Struct car Herbie-- I'm declaring a new variable of type struct car called

583
00:28:22,850 --> 00:28:23,800
Herbie--

584
00:28:23,800 --> 00:28:26,780
and I'm saying Herbie dot year equals 1963,

585
00:28:26,780 --> 00:28:29,720
Herbie dot model equals beetle, totally OK, right?

586
00:28:29,720 --> 00:28:32,810
Because in each case where I'm using year and model,

587
00:28:32,810 --> 00:28:37,870
I'm associating it with some structure of that data type, in this case Herbie.

588
00:28:37,870 --> 00:28:39,230
But I could never say this.

589
00:28:39,230 --> 00:28:44,240
Is not valid in C, at least with what we have here,

590
00:28:44,240 --> 00:28:47,840
because year and model don't just kind of hang out on their own.

591
00:28:47,840 --> 00:28:52,340
They're attached to what-- they're part of what it means to be a struct car.

592
00:28:52,340 --> 00:28:54,620
So we always have to associate them with a struct car.

593
00:28:54,620 --> 00:28:57,680
So that would not fly.

594
00:28:57,680 --> 00:28:59,450
So that's sort of the--

595
00:28:59,450 --> 00:29:04,347
that's sort of the analogy of object properties to C structure fields.

596
00:29:04,347 --> 00:29:07,055
But objects, in addition to having properties, also have methods.

597
00:29:07,055 --> 00:29:11,980
And you've heard me use that word a couple of times so far in this video.

598
00:29:11,980 --> 00:29:15,710
Methods are basically functions that are inherent to what

599
00:29:15,710 --> 00:29:16,760
it means to be an object.

600
00:29:16,760 --> 00:29:21,470
You can't call that function just kind of out of the blue on anything.

601
00:29:21,470 --> 00:29:26,150
You can only call that function on objects of that type,

602
00:29:26,150 --> 00:29:29,877
on objects where that function means something.

603
00:29:29,877 --> 00:29:32,210
So properties and methods don't ever stand on their own.

604
00:29:32,210 --> 00:29:34,790
They're always part of what it means to be an object.

605
00:29:34,790 --> 00:29:37,970
And because of this, objects become a lot more important.

606
00:29:37,970 --> 00:29:40,980
If you have these properties and you have these methods

607
00:29:40,980 --> 00:29:44,900
and they're always dependent on objects, that's where the term object oriented

608
00:29:44,900 --> 00:29:45,860
comes from.

609
00:29:45,860 --> 00:29:48,150
The object is the most important thing.

610
00:29:48,150 --> 00:29:54,620
We don't pass objects into a function, we call methods on objects.

611
00:29:54,620 --> 00:29:56,360
And that's the general syntax that you'll

612
00:29:56,360 --> 00:30:00,480
see in a lot of object oriented programming languages, is some object,

613
00:30:00,480 --> 00:30:01,940
and there is some method--

614
00:30:01,940 --> 00:30:04,231
which again, is just another word for a function-- that

615
00:30:04,231 --> 00:30:07,730
is associated with it that we are calling on that object.

616
00:30:07,730 --> 00:30:10,880
We'll take a look at an example of this in just a moment.

617
00:30:10,880 --> 00:30:12,670
Now objects are not necessarily generic.

618
00:30:12,670 --> 00:30:15,640
We can actually create our own specific kinds of objects

619
00:30:15,640 --> 00:30:19,000
just like we created our own specific types of structures in C.

620
00:30:19,000 --> 00:30:21,820
And the way we do that is using the class keyword.

621
00:30:21,820 --> 00:30:25,630
The class keyword introduces a new kind of object.

622
00:30:25,630 --> 00:30:28,630
Every class, so every new kind of object you create,

623
00:30:28,630 --> 00:30:30,670
requires an initialization function.

624
00:30:30,670 --> 00:30:33,820
We didn't have to do this in C. But basically what it does--

625
00:30:33,820 --> 00:30:37,420
and you'll also hear this term as a constructor,

626
00:30:37,420 --> 00:30:40,600
you'll hear that commonly used in languages like C++ for example--

627
00:30:40,600 --> 00:30:44,620
and basically what it does is it creates an object for you and it puts some--

628
00:30:44,620 --> 00:30:47,470
it assigns the value of some properties automatically.

629
00:30:47,470 --> 00:30:50,800
Remember that in Python we can only declare variables

630
00:30:50,800 --> 00:30:54,420
by assigning them a value.

631
00:30:54,420 --> 00:30:56,660
So basically, this is the analogous idea.

632
00:30:56,660 --> 00:30:59,940
We are creating an object of a particular class,

633
00:30:59,940 --> 00:31:02,930
and we are filling in all or many of the properties

634
00:31:02,930 --> 00:31:06,000
of that object with some data.

635
00:31:06,000 --> 00:31:09,030
Then, in addition to defining the properties of the object,

636
00:31:09,030 --> 00:31:14,330
we also have to define functions or methods that can apply to the object.

637
00:31:14,330 --> 00:31:17,984
Every method that we define inside of the class has at least one parameter,

638
00:31:17,984 --> 00:31:20,900
and that parameter is canonically-- although you don't have to call it

639
00:31:20,900 --> 00:31:21,530
this--

640
00:31:21,530 --> 00:31:25,850
is called self, and basically all it is is a reference to the object

641
00:31:25,850 --> 00:31:29,310
so that we can always know what object we are talking about.

642
00:31:29,310 --> 00:31:32,210
So every function that you write, every method

643
00:31:32,210 --> 00:31:36,440
that you write in a class to find some new kind of object,

644
00:31:36,440 --> 00:31:39,760
will always have one more parameter than you think you need,

645
00:31:39,760 --> 00:31:43,030
because the first parameter there will always be self.

646
00:31:43,030 --> 00:31:46,400
Let's try and distill this into some actual code

647
00:31:46,400 --> 00:31:49,150
so you can what we're doing here when we're talking about defining

648
00:31:49,150 --> 00:31:51,320
a new kind of class, defining some methods,

649
00:31:51,320 --> 00:31:57,410
and then we'll see how we can apply those methods to objects in that class.

650
00:31:57,410 --> 00:32:02,590
So here is a very simple class called student.

651
00:32:02,590 --> 00:32:04,842
So class Student with a capital S-- apparently this

652
00:32:04,842 --> 00:32:08,050
means that I am now going to create-- whenever I want to create a new student

653
00:32:08,050 --> 00:32:11,680
object I'll use that capital S Student keyword.

654
00:32:11,680 --> 00:32:13,400
And I'm defining three functions.

655
00:32:13,400 --> 00:32:16,180
The first is that constructor, that initialization function, which

656
00:32:16,180 --> 00:32:20,502
is always called underscore underscore init underscore underscore.

657
00:32:20,502 --> 00:32:22,960
Now, my Student apparently is going to have two properties.

658
00:32:22,960 --> 00:32:25,870
They're going to have a name and an ID.

659
00:32:25,870 --> 00:32:28,210
But because I'm defining a method inside of that class,

660
00:32:28,210 --> 00:32:30,760
I always have to include that self parameter so that I always

661
00:32:30,760 --> 00:32:35,697
know what object I am talking about or what object to being invoked here.

662
00:32:35,697 --> 00:32:39,030
Inside of my initialization function I'm doing something pretty straightforward.

663
00:32:39,030 --> 00:32:43,110
I'm just saying, self dot name equals name and self dot ID equals ID.

664
00:32:43,110 --> 00:32:48,630
So I'm assigning the name and ID properties of the Student object

665
00:32:48,630 --> 00:32:50,920
to be whatever I pass in here.

666
00:32:50,920 --> 00:32:53,110
And then I have another function called changeID,

667
00:32:53,110 --> 00:32:56,830
and apparently I use this to change the idea

668
00:32:56,830 --> 00:33:00,622
of a student, the ID number of a student after I've already created them.

669
00:33:00,622 --> 00:33:03,080
Because I'm assigning the ID when I initialize it, but here

670
00:33:03,080 --> 00:33:05,440
apparently I've already created the Student object

671
00:33:05,440 --> 00:33:07,030
and I'm going to change it.

672
00:33:07,030 --> 00:33:09,730
So changeID takes two parameter, self against so I

673
00:33:09,730 --> 00:33:14,520
know which Student, which capital S Student object I'm talking about,

674
00:33:14,520 --> 00:33:18,170
and the ID number that I want to change them to.

675
00:33:18,170 --> 00:33:21,981
And then I have a function called print, which takes just one parameter, self.

676
00:33:21,981 --> 00:33:23,980
It's apparently not going to take anything else,

677
00:33:23,980 --> 00:33:28,540
but still I always have to indicate the self parameter.

678
00:33:28,540 --> 00:33:32,360
Always has to be part of any methods that you define for a class

679
00:33:32,360 --> 00:33:33,400
that you create.

680
00:33:33,400 --> 00:33:37,300
And apparently what I'm doing here is printing out self dot name and self dot

681
00:33:37,300 --> 00:33:39,080
ID with a little dash between them.

682
00:33:39,080 --> 00:33:40,330
That's what's happening there.

683
00:33:40,330 --> 00:33:43,060
It's just some variable interpolation just like we saw before.

684
00:33:43,060 --> 00:33:47,560
I'm just printing out self dot name dash self dot ID.

685
00:33:47,560 --> 00:33:50,080
So what would happen here?

686
00:33:50,080 --> 00:33:54,310
So I'm creating a new variable, a new object, called Jane.

687
00:33:54,310 --> 00:33:56,219
And this is my initialization.

688
00:33:56,219 --> 00:33:57,760
I'm calling the constructor function.

689
00:33:57,760 --> 00:34:01,470
Jane equals Student with a capital S, again, that's the name of our class,

690
00:34:01,470 --> 00:34:02,920
and I'm passing in tow values.

691
00:34:02,920 --> 00:34:07,719
Jane, which I apparently want to map to self dot name, and 10.

692
00:34:07,719 --> 00:34:09,760
So immediately after this, what would happened is

693
00:34:09,760 --> 00:34:15,159
I would have a new student object called Jane,

694
00:34:15,159 --> 00:34:19,120
and Jane's name field would be Jane in quotes,

695
00:34:19,120 --> 00:34:21,500
and Jane's ID field would be 10.

696
00:34:21,500 --> 00:34:22,526
So if I printed it out--

697
00:34:22,526 --> 00:34:25,150
and you can actually take this code and recreate it in CS50 IDE

698
00:34:25,150 --> 00:34:27,489
and see it for yourself-- if I then printed it out,

699
00:34:27,489 --> 00:34:31,840
I would print out Jane space dash space 10.

700
00:34:31,840 --> 00:34:35,260
Then if I executed Jane dot changeID 11, you

701
00:34:35,260 --> 00:34:38,800
can probably guess what would happen because then when I print it again

702
00:34:38,800 --> 00:34:43,360
it would print Jane space dash space 11.

703
00:34:43,360 --> 00:34:47,620
So that's just some examples of creating-- of defining a class,

704
00:34:47,620 --> 00:34:50,310
defining methods, assigning properties.

705
00:34:50,310 --> 00:34:52,552
Again, all of this sort of is inherent to what

706
00:34:52,552 --> 00:34:55,510
it means in an object-- to be working in an object oriented programming

707
00:34:55,510 --> 00:34:56,389
language.

708
00:34:56,389 --> 00:34:59,659
So even though this may be very unfamiliar and new,

709
00:34:59,659 --> 00:35:03,340
especially coming from a language like C, this, if you go forward and do

710
00:35:03,340 --> 00:35:05,560
object oriented programming in languages like Python,

711
00:35:05,560 --> 00:35:08,320
like PHP, like JavaScript, or like many, many others,

712
00:35:08,320 --> 00:35:11,290
this sort of notion of methods, properties,

713
00:35:11,290 --> 00:35:16,171
and how we work with them is going to be really important to sort of synthesize.

714
00:35:16,171 --> 00:35:18,520
So if you haven't noticed by now, good style

715
00:35:18,520 --> 00:35:20,610
is really, really important in Python.

716
00:35:20,610 --> 00:35:23,080
We don't have curly braces anymore which is great,

717
00:35:23,080 --> 00:35:27,670
but we still need to be able to then indicate when a--

718
00:35:27,670 --> 00:35:30,130
how an if block is delimited.

719
00:35:30,130 --> 00:35:32,740
In C, we had an open curly brace, then we had some code,

720
00:35:32,740 --> 00:35:34,031
we had some closed curly brace.

721
00:35:34,031 --> 00:35:36,910
And it didn't really matter how things were styled in between.

722
00:35:36,910 --> 00:35:39,520
I mean it mattered for somebody who is reading your code,

723
00:35:39,520 --> 00:35:41,250
but it doesn't matter to the computer.

724
00:35:41,250 --> 00:35:42,580
It does matter in Python.

725
00:35:42,580 --> 00:35:47,620
Tabs and indentation are key in order to indicate what you intend for it to do.

726
00:35:47,620 --> 00:35:50,650
So if I had an if block and I put a colon at the end of it

727
00:35:50,650 --> 00:35:53,890
and I didn't indent the next line in, Python

728
00:35:53,890 --> 00:35:59,230
wouldn't know that that line is supposed to be subject to that if condition.

729
00:35:59,230 --> 00:36:05,240
So if you have not yet been in the habit of practicing good coding style,

730
00:36:05,240 --> 00:36:09,700
now is the time to definitely reacquaint yourself with the CS50 style guide,

731
00:36:09,700 --> 00:36:13,360
because if your code in Python is poorly styled,

732
00:36:13,360 --> 00:36:16,250
it's probably not going to work.

733
00:36:16,250 --> 00:36:19,220
Sorry about that.

734
00:36:19,220 --> 00:36:21,180
So in C, we had the notion of including files

735
00:36:21,180 --> 00:36:24,530
if we needed to get additional information from libraries,

736
00:36:24,530 --> 00:36:26,800
for example like standard IO or CS50 dot h.

737
00:36:26,800 --> 00:36:29,710
We can do the same thing in Python and C it was pound include.

738
00:36:29,710 --> 00:36:33,580
In Python, we import, and instead of being called header files or libraries,

739
00:36:33,580 --> 00:36:35,500
we generally call them modules.

740
00:36:35,500 --> 00:36:39,580
But we could import CD50, and if we do we could then call some of the CD50

741
00:36:39,580 --> 00:36:41,330
functions we might be familiar with.

742
00:36:41,330 --> 00:36:44,950
We can do that by saying for example, CD50 dot get int parentheses.

743
00:36:44,950 --> 00:36:50,090
And that would, just like get int does in C, get an integer from the user.

744
00:36:50,090 --> 00:36:52,840
CS50 dot get float, dot get string, dot get char.

745
00:36:52,840 --> 00:36:57,606
All those things that you've used in C, we can still use them in Python.

746
00:36:57,606 --> 00:36:59,230
They just take a little longer to type.

747
00:36:59,230 --> 00:37:06,060
We have to specify CS50 dot, because CS50 is basically, not exactly,

748
00:37:06,060 --> 00:37:08,110
but it's basically a class where we're defining

749
00:37:08,110 --> 00:37:14,570
a couple of different methods within it that we can then invoke.

750
00:37:14,570 --> 00:37:18,710
You can, in addition to pre-writing your files in dot py files,

751
00:37:18,710 --> 00:37:22,087
you can also just literally write Python using the Python interpreter

752
00:37:22,087 --> 00:37:22,920
at the command line.

753
00:37:22,920 --> 00:37:27,980
You can type in your IDE or in a lot of environments Python, and then hit Enter

754
00:37:27,980 --> 00:37:30,260
and it will open a Python interpreter.

755
00:37:30,260 --> 00:37:32,522
And you can literally write Python one line at a time.

756
00:37:32,522 --> 00:37:35,480
In general though, if you're going to be writing more complex programs,

757
00:37:35,480 --> 00:37:38,229
you're probably going to want to pre-write them and then load them

758
00:37:38,229 --> 00:37:40,130
into the Python interpreter instead.

759
00:37:40,130 --> 00:37:42,860
To invoke the Python interpreter, particular in CS50 IDE

760
00:37:42,860 --> 00:37:46,790
but again more generally, Python space whatever the file you want to invoke

761
00:37:46,790 --> 00:37:49,940
is, and then what will happen is the interpreter will open that file

762
00:37:49,940 --> 00:37:55,280
and proceed one line at a time, top to bottom, executing your Python code.

763
00:37:55,280 --> 00:37:59,870
And if you really want to make your Python programs look and run a lot more

764
00:37:59,870 --> 00:38:03,950
like C programs-- for example, in C, once we compile a program into--

765
00:38:03,950 --> 00:38:06,410
say we make hello, we then have dot slash hello--

766
00:38:06,410 --> 00:38:11,000
we can include this line in red at the very top of our Python file.

767
00:38:11,000 --> 00:38:15,890
And then we can execute the line in blue after we're done saving the file.

768
00:38:15,890 --> 00:38:18,440
And then we can actually instead of typing Python and then

769
00:38:18,440 --> 00:38:21,670
some whatever we want to call it dot pie, we could then just write dot

770
00:38:21,670 --> 00:38:25,640
slash blah blah blah dot pie.

771
00:38:25,640 --> 00:38:29,360
So again, I know that was a long video, there was a lot to cover in that one.

772
00:38:29,360 --> 00:38:33,950
And we've really only just scratched the surface of introducing you to Python.

773
00:38:33,950 --> 00:38:37,072
But it is an amazing language, incredibly flexible,

774
00:38:37,072 --> 00:38:40,030
and it's a tool you're really going to want to put in your programmer's

775
00:38:40,030 --> 00:38:44,160
toolbox if you're ever doing anything like data science or complex string

776
00:38:44,160 --> 00:38:46,910
manipulation or really just familiarizing yourself with a language

777
00:38:46,910 --> 00:38:50,352
that you can use both at the command line and in a web development context.

778
00:38:50,352 --> 00:38:53,310
And we'll talk about how we can use Python in a web development context

779
00:38:53,310 --> 00:38:55,810
in another video on flask.

780
00:38:55,810 --> 00:38:58,980
I'm Doug Lloyd, this is CS50.

781
00:38:58,980 --> 00:39:00,206


